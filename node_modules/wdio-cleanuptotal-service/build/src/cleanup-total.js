"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class CleanupTotal {
    constructor() {
        this._cleanupList = [];
        this._errorCount = 0;
    }
    /**
     * @deprecated Don't use this method if *wdio-cleanuptotal-service* is enabled.
     */
    initialize() {
        this._cleanupList = new Array();
        this._errorCount = 0;
    }
    /**
     *
     * @param cleanupFunction Insert a cleanup function to the cleanup stack.
     */
    addCleanup(cleanupFunction) {
        this._cleanupList.push(cleanupFunction);
    }
    /**
     * @deprecated Don't use this method if *wdio-cleanuptotal-service* is enabled.
     */
    finalize(serviceOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._cleanupList.length <= 0) {
                return;
            }
            let message = "";
            const processId = process.pid;
            this.printToLog(`CleanupTotal [${processId}]: ##### Cleanup initialized #####`, serviceOptions);
            this._cleanupList.reverse();
            for (let i = 0; i < this._cleanupList.length; i++) {
                try {
                    yield this._cleanupList[i]();
                    message = `CleanupTotal [ðŸ™‚ ${processId}]: Successfully executed '${this._cleanupList[i].toString()}'`;
                }
                catch (ex) {
                    this._errorCount++;
                    message = `CleanupTotal [ðŸ˜• ${processId}]: Failed to execute '${this._cleanupList[i].toString()}: ${ex}'`;
                }
                finally {
                    this.printToLog(message, serviceOptions);
                }
            }
            this._cleanupList.length = 0;
            if (this._errorCount > 0) {
                console.log(`CleanupTotal: Warning!!!: Cleanup for [${processId}] finished with ${this._errorCount} errors`);
            }
            this.printToLog(`CleanupTotal [${processId}]: ### Cleanup done ###`, serviceOptions);
        });
    }
    printToLog(message, serviceOptions) {
        console.log(message);
        if ((serviceOptions === null || serviceOptions === void 0 ? void 0 : serviceOptions.customLoggerMethod) != undefined) {
            try {
                serviceOptions.customLoggerMethod(message);
            }
            catch (err) {
                console.log(`CleanupTotal: printing to custom logger ${serviceOptions.customLoggerMethod.name} failed: ${err}`);
            }
        }
    }
}
exports.default = new CleanupTotal();
